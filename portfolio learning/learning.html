<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <link rel="stylesheet" href="learning.css">
</head>
<body>
    <header>
        <h1>Course Learning Reflections</h1>
    </header>

    <section class="content">
        <div class="card">
            <h2>1. Iteration, Recursion, Backtracking</h2>
            <p><strong>Iteration:</strong> Repeated execution of tasks (e.g., looping through an array).</p>
            <p><strong>Recursion:</strong> Solve problems by breaking them into smaller, similar subproblems (e.g., Fibonacci sequence).</p>
            <p><strong>Backtracking:</strong> Explore possible solutions and retract when unsuccessful (e.g., N-Queens problem).</p>
        </div>

        <div class="card">
            <h2>2. Space and Time Efficiency & Orders of Growth</h2>
            <p><strong>Space Efficiency:</strong> Measures the memory used by an algorithm.</p>
            <p><strong>Time Efficiency:</strong> Measures the time taken by an algorithm.</p>
            <p><strong>Orders of Growth:</strong> Classify complexity: O(n), O(n²), O(log n), etc.</p>
        </div>

        <div class="card">
            <h2>3. Design Principles</h2>
            <p><strong>Pruning:</strong> Optimizing by cutting off unnecessary paths (e.g., pruning in N-Queens).</p>
            <p><strong>Bit Manipulation:</strong> Operations on numbers at the bit level (e.g., used in Fenwick Tree).</p>
            <p><strong>Edge Relaxation:</strong> Reduces edge weights in graphs (e.g., used in Bellman-Ford algorithm).</p>
        </div>

        <div class="card">
            <h2>4. Tree Data Structures</h2>
            <p><strong>Red-Black Tree:</strong> A self-balancing binary search tree where each node has an extra bit for color. This helps ensure the tree remains balanced with O(log n) time complexity for search, insert, and delete.</p>
            <p><strong>AVL Tree:</strong> A self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one.</p>
            <p><strong>Trie:</strong> A tree-like data structure that stores strings, used for efficient retrieval of prefixes.</p>
        </div>

        <div class="card">
            <h2>5. Array Query Algorithms</h2>
            <p><strong>Pre-computation:</strong> Stores results of previous calculations for efficient future use (e.g., prefix sum array to quickly query sum of elements in an array).</p>
        </div>

        <div class="card">
            <h2>6. Trees and Graphs</h2>
            <p><strong>Trees:</strong> Hierarchical structures used in file systems, etc. They have no cycles and can be traversed using Preorder, Inorder, or Postorder methods.</p>
            <p><strong>Graphs:</strong> Can contain cycles. Used in social networks, routing algorithms, etc. They can be directed or undirected and can be weighted.</p>
        </div>

        <div class="card">
            <h2>7. Sorting and Searching</h2>
            <p><strong>Bubble Sort:</strong> A simple sorting algorithm with time complexity of O(n²), inefficient for large datasets.</p>
            <p><strong>Merge Sort:</strong> A divide-and-conquer algorithm with time complexity of O(n log n), much more efficient than Bubble Sort.</p>
            <p><strong>Quick Sort:</strong> A comparison-based sort with average time complexity of O(n log n), but worst case O(n²).</p>
            <p><strong>Heap Sort:</strong> Uses a heap data structure, O(n log n) time complexity, efficient and in-place.</p>
        </div>

        <div class="card">
            <h2>8. Spanning Trees and Shortest Path</h2>
            <p><strong>Kruskal's Algorithm:</strong> Finds minimum spanning tree by sorting edges and adding them without forming cycles.</p>
            <p><strong>Prim's Algorithm:</strong> Builds minimum spanning tree by starting with a random node and expanding by selecting the smallest edge connected to the tree.</p>
            <p><strong>Dijkstra's Algorithm:</strong> Finds the shortest path in a graph with non-negative edge weights using a greedy approach.</p>
            <p><strong>Bellman-Ford Algorithm:</strong> Solves single-source shortest path with negative weights, also detects negative weight cycles.</p>
            <p><strong>Floyd-Warshall Algorithm:</strong> Finds shortest paths between all pairs of nodes in a weighted graph.</p>
        </div>

        <div class="card">
            <h2>9. Algorithm Design Techniques</h2>
            <p><strong>Brute Force:</strong> Tries all possible solutions (e.g., Bubble Sort).</p>
            <p><strong>Divide and Conquer:</strong> Splits the problem into smaller parts (e.g., Merge Sort, Quick Sort).</p>
            <p><strong>Dynamic Programming:</strong> Breaks the problem into subproblems, solving each once (e.g., Bellman-Ford, Floyd-Warshall).</p>
            <p><strong>Greedy Algorithms:</strong> Makes the optimal choice at each step (e.g., Kruskal’s and Prim’s for minimum spanning tree).</p>
            <p><strong>Backtracking:</strong> Explores all potential solutions, discarding those that fail (e.g., N-Queens problem).</p>
        </div>
    </section>

    <footer>
        <p>Author: Shashank Sawkar | Roll No: 233</p>
    </footer>
</body>
</html>
